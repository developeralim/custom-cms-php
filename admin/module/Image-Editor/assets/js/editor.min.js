/* defined variables */
const ajax_endpoint = 'http://localhost/Image-Editor/functions.php'; 

/* actions and hook */
let actions = [];
/* to apply css on any node object */
(function(){
      Object.prototype.css = function css(css={}){
            for (const key in css) {
                  if (Object.hasOwnProperty.call(css, key)) {
                        this.style[key] = css[key];
                  }
            }
      }
}());
/**
 * @param {String s class or id to be selected} s 
 * @param {Object n node name defualt is document object} n 
 * @returns single node or an array of nodes  
 */
function $(s,n=document){
      var e = n.querySelectorAll(s);
      if(e.length === 1) return e[0];
      let el = [];
      e.forEach(element => {
            el.push(element);
      });
      return el;
}
/**
 * 
 * @param {Object n to which listener want to be added} n 
 * @param {CallableFunction c callback function which will be triggered when listener be occured} c 
 * @returns Boolean true
 */
Object.prototype.listener = function listener(n,c){
      if(this.length === 0) return;
      if(this instanceof Array){
            this.forEach(element => {
                  element.addEventListener(n,c);
            });
            return true;
      }
      this.addEventListener(n,c);
      return true;
}
/**
 * 
 * @param {CallableFunction callback will be called when mouseup listener be triggered} callback 
 * @returns mouse up instance
 */
Object.prototype.mouseup = function mouseup(callback){
      return this.listener('mouseup',callback);
}
/**
 * 
 * @param {CallableFunction callback will be called when mousemove listener be triggered} callback 
 * @returns mouse move instance
 */
Object.prototype.mousemove = function mousemove(callback){
      return this.listener('mousemove',callback);
}
/**
 * 
 * @param {String hookname under which user want to add actions} hookname 
 * @param {CallableFunction callback which will be triggered when hook is intialized} callback 
 * @param {Number priority to specify which function be invoked firstly} priority 
 * @param {Number accepted_args how many arguments can be passed in action callback function} accepted_args 
 * @returns Boolean true
 */
function add_action(hookname,callback,priority = 0,accepted_args = 0){
      actions[priority] = {
            hookname,
            callback,
            accepted_args,
      };
      return true;
}
/**
 * 
 * @param {String hookname to preserve callback functions under this} hookname 
 * @param  {Array args to pass arguments as an array according to accepted arguments} args 
 * @returns Boolean true;
 */
function do_action(hookname,...args){
      return new Promise(resolve => {
            for (const key in actions) {
                  if (Object.hasOwnProperty.call(actions, key)) {
                        const element = actions[key];
                        if(element.hookname == hookname){
                              eval(element.callback)(args.slice(0,parseInt(element.accepted_args)));
                        }
                  }
            }
            resolve(true);
      });
}
/*===================================================================== 
      rotate functionality 
=====================================================================*/
/* select how many divs contains rotate class */
const toRotates = $('.rotate');
/* assign initial rotating is false */
let targetRotateElement,targetRotateElementRect,isRotate = false;
(function(){
      /* check if toRotates is an array if it is be then loop over it to add rotatePointsContainer */
      if(toRotates instanceof Array) {
            toRotates.forEach(toRotate => rotateInit(toRotate));
      }else{
            rotateInit(toRotates);
      }
      /* assign isRotate false when mouse up event is triggered */
      document.mouseup(e => isRotate = false);
      /* do rotate when mouse move event triggered on document */
      document.mousemove(rotate);
}());
function rotateInit(toRotate){
      /* add position style to relative */
      let getPosition = window.getComputedStyle(toRotate).position;
      toRotate.css({
            position : getPosition == 'static' ? 'relative' : getPosition,
      });
      createRotatePoints(toRotate);
      return true;
}
/**
 * 
 * @param {Object toRotate in which html element user want to add rotate functionality} toRotate 
 * @returns Object toRotate after adding resize points to it
 */
function createRotatePoints(toRotate){
      /* create single points along with a class name */
      let point = document.createElement('span');
      /* a class to specify rotate direction */
      point.className = `rotate-point`;
      /* add click listener to every point to roate its parent div */
      point.listener('mousedown',e => {
            if(e.button !== 0) return;
            e.preventDefault();
            isRotate = true;
            targetRotateElement = e.target.parentElement;
            targetRotateElementRect = targetRotateElement.getBoundingClientRect();
      });
      /* append create point to that div which contains rotate class */
      toRotate.appendChild(point);
      return toRotate;
}
/**
 * 
 * @returns Boolean true
 */
function rotate(){
      var event = window.event;
      if(isRotate){
            let center_x = (targetRotateElementRect.left) + (targetRotateElementRect.width / 2);
            let center_y = (targetRotateElementRect.top) + (targetRotateElementRect.height / 2);
            let mouse_x = event.clientX;
            let mouse_y = event.clientY;
            var radians = Math.atan2(mouse_x - center_x,mouse_y - center_y);
            var degree = (radians * (180 / Math.PI) * -1) + 90;
            targetRotateElement.css({
                  transform : `rotate(${degree}deg)`,
            });
            /* call all actions */
            do_action('rotate',Object.entries({
                  event : event,
                  center_x : center_x,
                  center_y : center_y,
                  mouse_x : mouse_x,
                  mouse_y : mouse_y,
                  radians : radians,
                  degree : degree,
                  targetElement : targetRotateElement,
            }));

      }
      return true;
}
/* =============================================================================================
      move functionality
================================================================================================ */
const toMoves = $('.move');
/* assign initial rotating is false */
let targetMoveElement,targetMoveElementRect,targetMoveParentElementRect,isMoving = false;
let offset = {
      x : 0,
      y : 0,
};
(function(){
      if(toMoves instanceof Array){
            toMoves.forEach(toMove => {
                  applyMovement(toMove);
            });
      }else{
            applyMovement(toMoves);
      }
      /* assign isMoving false when mouse up event is triggered */
      document.mouseup(e => isMoving = false);
      /* do rotate when mouse move event triggered on document */
      document.mousemove(move);
}());
/**
 * 
 * @param {Object toMove which is gonna move} toMove 
 * @returns  Object toMove after adding listener to it
 */
function applyMovement(toMove){
      /* make cursor move on toMove element */
      toMove.css({
            position : 'absolute',
      });
      /* add position to absolute toMove element and postion to relative to its parent element */
      toMove.parentElement.css({
            position : 'relative',
      });
      toMove.listener('mousedown',e => {
            if(!e.target.classList.contains('move') || e.button !== 0) return;
            e.preventDefault();
            targetMoveElement = e.target;
            targetMoveElementRect = targetMoveElement.getBoundingClientRect();
            targetMoveParentElementRect = targetMoveElement.parentElement.getBoundingClientRect();
            offset.x = e.clientX - targetMoveElementRect.left;
            offset.y = e.clientY - targetMoveElementRect.top;
            isMoving = true;
      });

      return toMove;
}
/**
 * 
 * @returns Boolean true
 */
function move(){
      var e = window.event;
      if(isMoving){
            if(targetMoveParentElementRect.height === 0 || targetMoveParentElementRect.width === 0) return;
            let left = (e.clientX - targetMoveParentElementRect.left) - offset.x;
            let top = (e.clientY - targetMoveParentElementRect.top) - offset.y;
            /* check if the left position less than 0 */
            if(left <= 0){
                  left = 0;
            } 
            /* check if the top position less than 0 */
            if(top <= 0){
                  top = 0;
            } 
            /* check if right positin is greater than parent element width */
            if(left+targetMoveElementRect.width >= targetMoveParentElementRect.width){
                  left = targetMoveParentElementRect.width - targetMoveElementRect.width;
            } 
            /* check if bottom positin is greater than parent element height */
            if(top+targetMoveElementRect.height >= targetMoveParentElementRect.height){
                  top = targetMoveParentElementRect.height - targetMoveElementRect.height;
            } 
            left = Math.round(left);
            top = Math.round(top);
            /* get right space of current move element */
            let right = Math.round(targetMoveParentElementRect.width - (left + targetMoveElementRect.width));
            let bottom = Math.round(targetMoveParentElementRect.height - (top + targetMoveElementRect.height));
            /* set moving elemet left and top position */
            targetMoveElement.css({
                  left : `${left}px`,
                  top : `${top}px`,
            });
            /* check if bottom and right position less than 0 */
            if(right < 0) right = 0;
            if(bottom < 0) bottom = 0;
            /* call all actions */
            do_action('move',Object.entries({
                  event : e,
                  targetElement : targetMoveElement,
                  left : left,
                  top : top,
                  right : right,
                  bottom : bottom,
                  height : Math.round(targetMoveElementRect.height),
                  width : Math.round(targetMoveElementRect.width),
            }));
      }
      return true;
}
/* =============================================================================================
      resize functionality
================================================================================================ */
const toResizes = $('.resize');
/* assign initial resizing is false */
let targetResizeElement,targetResizeElementRect,targetResizeParentElementRect,isResizing = false;
/* object for containig resize related key value paris */
let resizeOptions = {
      leftStart : 0,
      topStart : 0,
      elementLeft : 0,
      elementTop : 0,
      cursorType : '',
};
(function(){
      if(toResizes instanceof Array){
            toResizes.forEach(toResize => {
                  /* inject some resize points to the resize class contained div */
                  injectResizePoints(toResize);
                  applyResize(toResize);
            });
      }else{
            /* inject some resize points to the resize class contained div */
            injectResizePoints(toResizes);
            applyResize(toResizes);
      }
      /* assign isMoving false when mouse up event is triggered */
      document.mouseup(e => isResizing = false);
      /* do resize when mouse move event triggered on document */
      document.mousemove(resize);
}());
/**
 * 
 * @param {Object toResize which is gonna be resized} toResize 
 * @returns Object toResize after adding listener to it
 */
function applyResize(toResize){
      toResize.listener('mousedown',e => {
            if(!e.target.classList.contains('resize-point') || e.button !== 0) return;
            targetResizeElement = toResize;
            targetResizeElementRect = targetResizeElement.getBoundingClientRect();
            targetResizeParentElementRect = targetResizeElement.parentElement.getBoundingClientRect();
            /* set resize options */
            resizeOptions.leftStart = Math.floor(e.clientX - targetResizeParentElementRect.left);
            resizeOptions.topStart = Math.floor(e.clientY - targetResizeParentElementRect.top);
            resizeOptions.elementLeft = parseInt(window.getComputedStyle(targetResizeElement).left);
            resizeOptions.elementTop = parseInt( window.getComputedStyle(targetResizeElement).top);
            resizeOptions.cursorType = window.getComputedStyle(e.target).cursor;
            /* set isResizing to true */
            isResizing = true;
      });
      return toResize;
}
/**
 * 
 * @returns Boolean true
 */
function resize(){
      var e = window.event;
      if(isResizing){
            let resizeData;
            switch (resizeOptions.cursorType) {
                  case 'nw-resize':
                        resizeData = resizeFromTopLeftCorner(e,false);
                        break;
                  case 'ne-resize':
                        resizeData = resizeFromTopRightCorner(e,false);
                        break;
                  case 'nwse-resize':
                        resizeData = resizeFromBottomRightCorner(e,false);
                        break;
                  case 'nesw-resize':
                        resizeData = resizeFromBottomLeftCorner(e,false);
                        break;
                  case 'n-resize':
                        resizeData = resizeFromTopLeftCorner(e,true);
                        break;
                  case 'ew-resize':
                        resizeData = resizeFromTopRightCorner(e,true);
                        break;
                  case 'ns-resize':
                        resizeData = resizeFromBottomRightCorner(e,true);
                        break;
                  case 'e-resize':
                        resizeData = resizeFromBottomLeftCorner(e,true);
                        break;
            }
            /* add some extra data to resize data object */
            resizeData.event = e;
            resizeData.targetResizeElement = targetResizeElement;
            resizeData.targetResizeElementRect = targetResizeElementRect;
            resizeData.targetResizeParentElementRect = targetResizeParentElementRect;
            do_action('resize',Object.entries(resizeData));
      }
      return true;
}
/**
 * 
 * @param {Object toResize where user want to add resize points} toResize 
 * @returns Boolean true
 */
function injectResizePoints(toResize){
      /* check for position of toResize div */
      if(window.getComputedStyle(toResize).position == 'static'){
            /* assign postion to relative */
            toResize.css({
                  position : 'relative',
            });
      }
      const resizePoints = ['r-top-left','r-top-right','r-bottom-left','r-bottom-right','r-top','r-left','r-right','r-bottom',];
      resizePoints.forEach(point => {
            let resizePoint = document.createElement('span');
            resizePoint.className = `resize-point ${point}`;
            /* append created class to toResize div */
            toResize.appendChild(resizePoint);
      });
      return true;
}
/* ==========================================================================
      resize from all sides functionality
=============================================================================*/
/**
 * 
 * @param {Object eventlistener event} e 
 * @param {Boolean onlyTop side can be resized} onlyTop 
 * @returns Object which contains all necessary parameters 
 */
function resizeFromTopLeftCorner(e,onlyTop = false){
      let extendLeftfromTop = resizeOptions.leftStart - Math.floor(e.clientX - targetResizeParentElementRect.left);
      let extendTopFromLeft = resizeOptions.topStart - Math.floor(e.clientY - targetResizeParentElementRect.top);
      // check if extend left greater than current focus element left space
      if(extendLeftfromTop >= resizeOptions.elementLeft){
            extendLeftfromTop = resizeOptions.elementLeft;
      }
      // check if extend top greater than current focus element top space
      if(extendTopFromLeft >= resizeOptions.elementTop){
            extendTopFromLeft = resizeOptions.elementTop;
      }
      // check if the extend left less current focus element width
      if(extendLeftfromTop <= -targetResizeElementRect.width){
            extendLeftfromTop = -targetResizeElementRect.width;
      }
      // check if the extend top less than current focus element height
      if(extendTopFromLeft <= -targetResizeElementRect.height){
            extendTopFromLeft = -targetResizeElementRect.height;
      }
      /* variables to contain top left height and width */
      let top = resizeOptions.topStart - extendTopFromLeft;
      let left = resizeOptions.leftStart - extendLeftfromTop;
      let width = extendLeftfromTop + targetResizeElementRect.width;
      let height = extendTopFromLeft + targetResizeElementRect.height;
      if(onlyTop){
            targetResizeElement.css({
                  height : `${ height }px`,
                  top : `${ top }px`,
            }); 
      }else{
            targetResizeElement.css({
                  width : `${ width }px`,
                  left : `${ left }px`,
                  height : `${ height }px`,
                  top : `${ top }px`,
            }); 
      }
      var data = {
            width,
            height,
            top,
            onlyTop,
            extendLeftfromTop,
            extendTopFromLeft,
      };   

      if(onlyTop == false) data.left = left;
      return data;    
}
/**
 * 
 * @param {Object eventlistener event} e 
 * @param {Boolean onlyTop side can be resized} onlyRight 
 * @returns Object which contains all necessary parameters 
 */
function resizeFromTopRightCorner(e,onlyRight=false){

      let extendRightfromTop = Math.floor(e.clientX - targetResizeParentElementRect.left) - resizeOptions.leftStart;
      let extendTopFromRight = resizeOptions.topStart - Math.floor(e.clientY - targetResizeParentElementRect.top);
      // current focus element right space
      let currentFocusElementRightSpaceFromTop = Math.floor(targetResizeParentElementRect.right - targetResizeElementRect.right);
      // prevent over extending to right
      if( extendRightfromTop >= currentFocusElementRightSpaceFromTop){
            extendRightfromTop = currentFocusElementRightSpaceFromTop;
      }
      // check if extend top greater than current focus element top space
      if(extendTopFromRight >= resizeOptions.elementTop){
            extendTopFromRight = resizeOptions.elementTop;
      }
      // check if the extend top less than current focus element height
      if(extendTopFromRight <= -targetResizeElementRect.height){
            extendTopFromRight = -targetResizeElementRect.height;
      }
      /* variables to contain top left height and width */
      let width = targetResizeElementRect.width + extendRightfromTop;
      let height = targetResizeElementRect.height + extendTopFromRight;
      let top = resizeOptions.elementTop - extendTopFromRight;
      if(onlyRight){
            targetResizeElement.css({
                  width : `${width}px`,
            });
      }else{
            targetResizeElement.css({
                  width : `${width}px`,
                  height : `${height}px`,
                  top : `${top}px`,
            });
      }
      return {
            width,
            height,
            top,
            onlyRight,
            extendRightfromTop,
            extendTopFromRight,
            currentFocusElementRightSpaceFromTop
      };
}
/**
 * 
 * @param {Object eventlistener event} e 
 * @param {Boolean onlyTop side can be resized} onlyLeft 
 * @returns Object which contains all necessary parameters 
 */
function resizeFromBottomLeftCorner(e,onlyLeft=false){
      let extendLeftfrombottom = resizeOptions.leftStart - Math.floor(e.clientX - targetResizeParentElementRect.left);
      let extendBottomFromleft = Math.floor(e.clientY - targetResizeParentElementRect.top) - resizeOptions.topStart;
      // get current focus element bottom space
      let currentFocusElementBottomSpace = Math.floor(targetResizeParentElementRect.bottom - targetResizeElementRect.bottom);
      //prevent height expanding from bottom left corner
      if(extendBottomFromleft >= currentFocusElementBottomSpace){
            extendBottomFromleft = currentFocusElementBottomSpace;
      }
      // check if extend left greater than current focus element left space
      if(extendLeftfrombottom >= resizeOptions.elementLeft){
            extendLeftfrombottom = resizeOptions.elementLeft;
      }
      // check if the extend left less current focus element width
      if(extendLeftfrombottom <= -targetResizeElementRect.width){
            extendLeftfrombottom = -targetResizeElementRect.width;
      }
      /* some variables to assign widht height and left position */
      let width = extendLeftfrombottom + targetResizeElementRect.width;
      let height = extendBottomFromleft + targetResizeElementRect.height;
      let left = resizeOptions.elementLeft - extendLeftfrombottom;
      if(onlyLeft){
            targetResizeElement.css({
                  width : `${width}px`,
                  left : `${left}px`,
            })
      }else{
            targetResizeElement.css({
                  width : `${width}px`,
                  left : `${left}px`,
                  height : `${height}px`
            });
      };  

      return {
            width,
            height,
            left,
            onlyLeft,
            currentFocusElementBottomSpace,
            extendBottomFromleft,
            extendLeftfrombottom,
      };
}
/**
 * 
 * @param {Object eventlistener event} e 
 * @param {Boolean onlyTop side can be resized} onlyBottom 
 * @returns Object which contains all necessary parameters 
 */
function resizeFromBottomRightCorner(e,onlyBottom=false){
      let extendRightfrombottom = Math.floor(e.clientX - targetResizeParentElementRect.left) - resizeOptions.leftStart;
      let extendBottomFromRight = Math.floor(e.clientY - targetResizeParentElementRect.top) - resizeOptions.topStart;
      // current focus element right space
      let currentFocusElementRightSpaceFromBottom = Math.floor(targetResizeParentElementRect.right - targetResizeElementRect.right);
      // current focus element bottom space
      let currentFocusElementBottomSpaceFromRight = Math.floor(targetResizeParentElementRect.bottom - targetResizeElementRect.bottom);
      // prevent over extending to right
      if( extendRightfrombottom >= currentFocusElementRightSpaceFromBottom){
            extendRightfrombottom = currentFocusElementRightSpaceFromBottom;
      }
      // check if extend bottom from right greater than current focus element height
      if(extendBottomFromRight >= currentFocusElementBottomSpaceFromRight){
            extendBottomFromRight = currentFocusElementBottomSpaceFromRight;
      }
      /* some variables to asing height and width */
      let width = targetResizeElementRect.width + extendRightfrombottom;
      let height = targetResizeElementRect.height + extendBottomFromRight;
      if(onlyBottom){
            targetResizeElement.css({
                  height : `${height}px`
            }); 
      }else{
            targetResizeElement.css({
                  width : `${width}px`,
                  height : `${height}px`
            }); 
      }
      return {
            width,
            height,
            onlyBottom,
            extendRightfrombottom,
            extendBottomFromRight,
            currentFocusElementRightSpaceFromBottom,
            currentFocusElementBottomSpaceFromRight,
      };
}
/* ===============================================================================================
      Image Upload Functionality
==================================================================================================*/
/* select how many elements contains upload class */
const uploads = $('.uploads');
(async function(){
      if(uploads instanceof Array){
            uploads.forEach(upload => {
                  injectUploadComponent(upload);
            });
      }else{
            /* inject upload components to this element */
            injectUploadComponent(uploads);
      }
}());
/**
 * 
 * @param {Object to which element will be injected the componenet} upload 
 * @returns Boolean true
 */
function injectUploadComponent(upload){
      /* Object for containing some data to inject to this componenet */
      let data = {
            formClass : 'image_upload',
            enctype : 'multipart/form-data',
            method : 'POST',
            dragPartClass : 'drag-area',
            dragePartInnerClass : 'drag_inner',
            inputWraperClass : 'select-input',
            inputRequired : 'required',
            inputName : 'image',
            inputClass : 'image-upload',
            instadeButtonText : '<strong>Choose a file</strong> or drag it here',
            hintClass : 'hint',
            icon : '<svg class="box__icon" xmlns="http://www.w3.org/2000/svg" width="50" height="43" viewBox="0 0 50 43"><path d="M48.4 26.5c-.9 0-1.7.7-1.7 1.7v11.6h-43.3v-11.6c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v13.2c0 .9.7 1.7 1.7 1.7h46.7c.9 0 1.7-.7 1.7-1.7v-13.2c0-1-.7-1.7-1.7-1.7zm-24.5 6.1c.3.3.8.5 1.2.5.4 0 .9-.2 1.2-.5l10-11.6c.7-.7.7-1.7 0-2.4s-1.7-.7-2.4 0l-7.1 8.3v-25.3c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v25.3l-7.1-8.3c-.7-.7-1.7-.7-2.4 0s-.7 1.7 0 2.4l10 11.6z"></path></svg>',
            target : upload,
            multipleFile : upload.hasAttribute('multiple') ? upload.getAttribute('multiple') : '',
      }
      upload.innerHTML = `<form method="${data.method}" enctype="${data.enctype}" class="${data.formClass}">
            <div class="${data.dragPartClass}">
                  <div class="${data.dragePartInnerClass}">
                        ${data.icon}
                        <div class="${data.inputWraperClass}">
                              <input type="file" ${data.inputRequired} ${data.multipleFile} name="${data.inputName}" class="${data.inputClass}">
                              <button type="button">${data.instadeButtonText}</button>
                        </div>
                  </div>
            </div>
            <div class="img-progress-bar">
                  <div class="progress">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100" style="width:75%"></div>
                  </div>
                  <div class="${data.hintClass}"></div>
            </div>
      </form>`;

      /* add some listener */
      $(`.${data.inputWraperClass} button`).listener('click',e => openSelectWindow(e.currentTarget));
      $(`.${data.dragPartClass}`).listener('dragenter',e => drageEnter(upload));
      $(`.${data.dragPartClass}`).listener('dragleave',e => drageLeave(upload));
      $(`.${data.dragPartClass}`).listener('drop',e => drop(upload));
      $(`.${data.dragPartClass}`).listener('dragover',e => dragOver(upload));
      /* upload file by selecting files */
      $(`.${data.inputWraperClass} input`).listener('change',e => uploadImage([Object.entries({
            event : e,
            files : e.target.files,
            target : upload,
      })]));
      /* do all action with this hook */
      do_action('injectUploadComponent',Object.entries(data));
      return true;
}
/**
 * 
 * @param {Object btn to opent select window} btn 
 * @returns Boolean true
 */
function openSelectWindow(btn){
      btn.previousElementSibling.click();
      return true;
}
/**
 * 
 * @param {Object upload on which drag will be entered} upload 
 * @returns Boolean true
 */
function drageEnter(upload){
      /* add dragover class to it */
      upload.classList.add("dragenter");
      /* make upload element draggable */
      upload.draggable = true;
      /* make drag inner part of upload pointer event to none */
      $('svg',upload).css({
            pointerEvents : 'none', 
      });
      $('.select-input',upload).css({
            pointerEvents : 'none', 
      });
      /* do all actions with this hook */
      do_action('drageEnter',Object.entries({
            event : window.event,
            target : upload,
      }));
      /* return boolean true */
      return true;
}
/**
 * 
 * @param {Object upload from which drag will be leaved} upload 
 * @returns Boolean true
 */
function drageLeave(upload){
      /* remove dragover class to it */
      upload.classList.remove("dragenter");
      /* make upload element draggable */
      upload.draggable = false;
      /* make drag inner part of upload pointer event to none */
      $('svg',upload).css({
            pointerEvents : '', 
      });
      $('.select-input',upload).css({
            pointerEvents : '', 
      });
      /* do all actions with this hook */
      do_action('drageLeave',Object.entries({
            event : window.event,
            target : upload,
      }));
      /* return boolean true */
      return true;
}
/**
 * 
 * @param {Object upload on which drag will be over} upload 
 * @returns Boolean true
 */
function dragOver(upload){
      var event = window.event;
      event.preventDefault();
      /* do all actions with this hook */
      do_action('dragOver',Object.entries({
            event : event,
            target : upload,
      }));
      return true;
}
/**
 * 
 * @param {Object upload on which the drag will be dropped} upload 
 * @returns Boolean true
 */
function drop(upload){
      var event = window.event;
      event.preventDefault();
      /* remove dragover class to it */
      upload.classList.remove("dragenter");
      /* make drag inner part of upload pointer event to none */
      $('svg',upload).css({
            pointerEvents : '', 
      });
      $('.select-input',upload).css({
            pointerEvents : '', 
      });
      /* do all actions with this hook */
      do_action('drop',Object.entries({
            event : event,
            target : upload,
            files : event.dataTransfer.files
      }));
      return true;
}
/**
 * 
 * @param {Object uploaded file data} data 
 * @returns Boolean true
 */
function uploadImage(data){
      const fileData = Object.fromEntries(data[0]);
      const uploadDir = fileData.target.hasAttribute('dir') ? fileData.target.getAttribute('dir') : '';
      const multipleFile = fileData.target.hasAttribute('multiple') ? fileData.target.getAttribute('multiple') : '';
      /* set file type */
      const fileType = fileData.target.hasAttribute('type') ? fileData.target.getAttribute('type') : 'image';
      /* parse all files */
      let files = [];
      for (const file of fileData.files) {
            if(file.type.split('/')[0] === fileType.toLowerCase()){
                  files.push(file);
            }else{
                  alert(`${file.name} is not a ${fileType}`);
            }
      }
      /* check files exist or not */
      if(files.length == 0) {
            $('form',fileData.target).reset();
            return;
      };
      /* form data object to contain files */
      const formData = new FormData();
      /* loop over files array */
      for (let i = 0; i < files.length; i++) {
            formData.append(`file${i}`,files[i]);
            /* check if multiple file should be uploaded */
            if(multipleFile.toLowerCase() !== 'multiple') break;
      }
      /* append path to form data object */
      formData.append('file_upload',true);
      formData.append('upload_dir',uploadDir);
      /* ajax listener to upload files to server  */
      var ajax = new XMLHttpRequest();
      ajax.upload.addEventListener("progress",(e) => {
            progressHandler(e,fileData.target);
      },false);
      ajax.addEventListener("load",(e) => {
            completeHandler(e,fileData.target);
      },false);
      ajax.open("POST",'http://localhost/Image-Editor/functions.php',true);
      ajax.send(formData);
      /* do all actions with this hook */
      do_action('uploadImage',Object.entries({
            uploadDir,
            multipleFile,
            files,
            fileData,
      }));
}
add_action('drop','uploadImage',0,15);
/**
 * 
 * @param {Object event of uploading progress} e 
 * @param {Object on which upload event is occuring} upload 
 * @returns 
 */
function progressHandler(e,upload){
      var percent = Math.round(e.loaded / e.total) * 100;
      /* get the progress bar */
      $('.progress-bar',upload).setAttribute('aria-valuenow',percent);
      $('.progress-bar',upload).css({
            width : `${percent}%`,
      });
      //conver byte to mb
      let MB,size;
      MB = e.total / Math.pow(1024,2);
      if(MB < 1){
            size = Math.round(e.total / Math.pow(1024,1)) + 'KB';
      }else if(MB >= 1024 && MB < Math.pow(1024,3)){
            size = Math.round(e.total / Math.pow(1024,3)) + 'MB';
      }else if(MB >= Math.pow(1024,3) && MB < Math.pow(1024,4)){
            size = Math.round(e.total / Math.pow(1024,4)) + 'TB';
      }else if(MB >= Math.pow(1024,4) && MB < Math.pow(1024,5)){
            size = Math.round(e.total / Math.pow(1024,5)) + 'ZB';
      }else{
            size = Math.round(MB) + 'MB';
      }
      $('.img-progress-bar',upload).css({
            display : 'flex',
      });
      $('.hint',upload).innerHTML = `Upload ${percent}% of ${size}`;
      /* do all actions with this hook */
      do_action('progressHandler',Object.entries({
            percent,
            event : e,
            target : upload,
      }));

      return true;
}
/**
 * 
 * @param {Object event of complete upload file} e 
 * @param {Object on which upload event is occuring} upload 
 * @returns 
 */
function completeHandler(e,upload){
      $('.hint',upload).innerHTML = `<span style="color:green;">Upload Complete</span>`;
      $('form',upload).reset();
      var response = JSON.parse(e.target.responseText);
      /* do all actions with this hook */
      do_action('completeHandler',Object.entries({
            response,
            event : e,
            target : upload,
      }));
      return true;
}
/**
 * 
 * @returns fonts promise
 */
function getGoogleFonts(){
      return new Promise(resolve => {
            const hitUrl = 'https://www.googleapis.com/webfonts/v1/webfonts?key=AIzaSyA10ERLu9M3T1lAyKXOzaZ5TnohnSZKRsw';
            // send request for getting fonts list
            fetch(hitUrl,{
                  method : 'GET'
            })
            .then(res => res.json())
            .then(data => resolve(data))
            .catch(err => console.log(err));
      });
}
/*================================================================================
      draw functionality
==================================================================================*/
let draw = {
      drawMouseStartleft  : 0,
      drawMouseStartTop   : 0,
      drawWidth           : 0,
      drawheight          : 0,
      previewCanvas       : $('.canvas'),
      previewCanvasRect : null,
      currentCropper : null,
}
let isDrawing = false;

const drawCanvas = $('.draw-canvas');

(async function(){
      if(drawCanvas instanceof Array){
            drawCanvas.forEach(canvas => {
                  initializeDraw(canvas);
            });
      }else{
            initializeDraw(canvas);
      }

}());

function initializeDraw(drawCanvas){
      drawCanvas.listener('mousedown',mouseDown);
      document.listener('mouseup',mouseUp);
      document.listener('mousemove',drawItem);
      document.listener('keydown',e => draw.currentKey = e.key);
      document.listener('keyup',e => draw.currentKey = null);
}

function mouseDown(){
      var e = window.event;
      if(e.button !== 0) return;
      /* check if current target is not canvas */
      if(e.target.id !== 'main-canvas') return;
      /* remove all cropper which is exist right now */
      document.querySelectorAll('.cropper').forEach(cropper => cropper.parentElement.removeChild(cropper));
      /* set class name and attribute name */
      var element = document.createElement("div");
      element.setAttribute("data-id","cropper");
      /* set current cropper */
      draw.currentCropper = element;
      /* append cropper to preview canvas */
      $('.canvas').insertBefore(draw.currentCropper,$('#main-canvas'));
      // set preview canvas rect
      draw.previewCanvasRect = draw.previewCanvas.getBoundingClientRect();
      isDrawing = true;
      /* set mouse start position */
      draw.drawMouseStartleft = e.clientX - draw.previewCanvasRect.left;
      draw.drawMouseStartTop = e.clientY - draw.previewCanvasRect.top;
      draw.drawWidth = 0;
      draw.drawheight = 0;
      /* do all actions */
      element.className = `resize move cropper`;
      /* apply resize and move functionality */
      injectResizePoints(element);
      applyResize(element);
      applyMovement(element);  
      /* set resize dimension to */
      $('#resize-image #from-left').value = `${Math.floor(draw.drawMouseStartleft)}px`;
      $('#resize-image #from-top').value = `${Math.floor(draw.drawMouseStartTop)}px`;
      $('#resize-image #resize-width').value = draw.drawWidth;
      $('#resize-image #resize-height').value = draw.drawheight;
      /* set backgorund image when cropping */
      element.css({
            background : `url('${editorProperties.currentCanvasBlobURL}')`,
            backgroundPosition : `-${Math.floor(draw.drawMouseStartleft)}px -${Math.floor(draw.drawMouseStartTop)}px`,
      });
      /* set some css */
      draw.previewCanvas.classList.add('cropping'); 
      /* do all actions with this hook */
      do_action('mouseDown',Object.entries(draw));
      return true;
}
function mouseUp(){
      var e = window.event;
      isDrawing = false;
      if(draw.drawWidth === 0 || draw.drawheight === 0){
            if(draw.currentCropper !== null){
                  draw.previewCanvas.removeChild(draw.currentCropper);
            }
      }
      /* do all actions */
      draw.event = e;
      do_action('mouseUp',Object.entries(draw));
}

function drawItem(){
      var e = window.event;

      if(isDrawing){
            draw.drawWidth = (e.clientX - draw.previewCanvasRect.left) - draw.drawMouseStartleft;
            draw.drawheight = (e.clientY - draw.previewCanvasRect.top) - draw.drawMouseStartTop;
            /* check if height and width is not greater than preview canvas height and width */
            if(draw.drawWidth + draw.drawMouseStartleft >= draw.previewCanvasRect.width){
                  draw.drawWidth = draw.previewCanvasRect.width - draw.drawMouseStartleft;
            }
            if(draw.drawheight + draw.drawMouseStartTop >= draw.previewCanvasRect.height){
                  draw.drawheight = draw.previewCanvasRect.height - draw.drawMouseStartTop;
            }
            /* apply css on drawn cropper */
            draw.currentCropper.css({
                  width : `${draw.drawWidth}px`,
                  height : `${draw.drawheight}px`,
                  position : 'absolute',
                  top : `${draw.drawMouseStartTop}px`,
                  left : `${draw.drawMouseStartleft}px`,
                  backgroundPosition : `-${draw.drawMouseStartleft}px -${draw.drawMouseStartTop}px`,
            });
            /* set resize dimension to */
            $('#resize-image #resize-width').value = `${Math.floor(draw.drawWidth)}px`;
            $('#resize-image #resize-height').value= `${Math.floor(draw.drawheight)}px`;
            /* do all actions */
            draw.event = e;
            do_action('drawItem',Object.entries(draw));
      }
}

/**
 * 
 * @returns String unique text
 */
function makeid() {
      var text = "";
      var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    
      for (var i = 0; i < 5; i++)
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    
      return text;
}
/* parse size */
function parseSize(size){
      let s;
      /* check fo KB & MB*/
      if(size / 1024 < 1024){
            s = `${Math.round(size / 1024)}KB`;
      }else if(size / 1024 < (1024 * 1024)){
            s = `${Math.round(size / (1024 * 1024))}MB`;
      }else if(size / 1024 < (1024 * 1024 * 1024)){
            s = `${Math.round(size / (1024 * 1024 * 1024))}GB`;
      }else if(size / 1024 < (1024 * 1024 * 1024 *1024)){
            s = `${Math.round(size / (1024 * 1024 * 1024 * 1024))}TB`;
      }

      return s;
}